#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::useless_transmute)]
/* automatically generated by rust-bindgen 0.59.2 */
/* then modified manually for now */

pub const USB_SEGMENT_SIZE: u32 = 64;
pub const IO_USB_MAX_ENDPOINTS: u32 = 6;
pub const ENDORSEMENT_MAX_ASN1_LENGTH: u32 = 72;
pub const OS_PARSE_BERTLV_OFFSET_COMPARE_WITH_BUFFER: u32 = 2147483648;
pub const OS_PARSE_BERTLV_OFFSET_GET_LENGTH: u32 = 1073741824;
pub const APPLICATION_FLAG_MAIN: u32 = 1;
pub const APPLICATION_FLAG_BOLOS_UPGRADE: u32 = 2;
pub const APPLICATION_FLAG_SIGNED: u32 = 4;
pub const APPLICATION_FLAG_BOLOS_UX: u32 = 8;
pub const APPLICATION_FLAG_DERIVE_MASTER: u32 = 16;
pub const APPLICATION_FLAG_SHARED_NVRAM: u32 = 32;
pub const APPLICATION_FLAG_GLOBAL_PIN: u32 = 64;
pub const APPLICATION_FLAG_DEBUG: u32 = 128;
pub const APPLICATION_FLAG_AUTOBOOT: u32 = 256;
pub const APPLICATION_FLAG_BOLOS_SETTINGS: u32 = 512;
pub const APPLICATION_FLAG_CUSTOM_CA: u32 = 1024;
pub const APPLICATION_FLAG_LIBRARY: u32 = 2048;
pub const APPLICATION_FLAG_NO_RUN: u32 = 4096;
pub const APPLICATION_FLAG_ISSUER: u32 = 16384;
pub const APPLICATION_FLAG_ENABLED: u32 = 32768;
pub const APPLICATION_FLAG_AEM_PIN: u32 = 8;
pub const APPLICATION_FLAG_NEG_MASK: u32 = 4294901760;
pub const BOLOS_TRUE: u32 = 170;
pub const BOLOS_FALSE: u32 = 85;
pub const BOLOS_UX_OK: u32 = 170;
pub const BOLOS_UX_CANCEL: u32 = 85;
pub const BOLOS_UX_ERROR: u32 = 214;
pub const BOLOS_UX_IGNORE: u32 = 151;
pub const BOLOS_UX_REDRAW: u32 = 105;
pub const BOLOS_UX_CONTINUE: u32 = 0;
pub const OS_FLAG_RECOVERY: u32 = 1;
pub const OS_FLAG_SIGNED_MCU_CODE: u32 = 2;
pub const OS_FLAG_ONBOARDED: u32 = 4;
pub const OS_FLAG_PIN_VALIDATED: u32 = 128;
pub const IMPL_IO_APDU_BUFFER_SIZE: u32 = 260;
pub const IO_APDU_BUFFER_SIZE: u32 = 260;
pub const CHANNEL_APDU: u32 = 0;
pub const CHANNEL_KEYBOARD: u32 = 1;
pub const CHANNEL_SPI: u32 = 2;
pub const IO_RESET_AFTER_REPLIED: u32 = 128;
pub const IO_RECEIVE_DATA: u32 = 64;
pub const IO_RETURN_AFTER_TX: u32 = 32;
pub const IO_ASYNCH_REPLY: u32 = 16;
pub const IO_FINISHED: u32 = 8;
pub const IO_FLAGS: u32 = 248;
pub const BLE_SEGMENT_SIZE: u32 = 64;
pub const DEFAULT_PIN_RETRIES: u32 = 3;
pub const CX_OK: u32 = 0;
pub const CX_CARRY: u32 = 4294967073;
pub const CX_LOCKED: u32 = 4294967169;
pub const CX_UNLOCKED: u32 = 4294967170;
pub const CX_NOT_LOCKED: u32 = 4294967171;
pub const CX_NOT_UNLOCKED: u32 = 4294967172;
pub const CX_INTERNAL_ERROR: u32 = 4294967173;
pub const CX_INVALID_PARAMETER_SIZE: u32 = 4294967174;
pub const CX_INVALID_PARAMETER_VALUE: u32 = 4294967175;
pub const CX_INVALID_PARAMETER: u32 = 4294967176;
pub const CX_NOT_INVERTIBLE: u32 = 4294967177;
pub const CX_OVERFLOW: u32 = 4294967178;
pub const CX_MEMORY_FULL: u32 = 4294967179;
pub const CX_NO_RESIDUE: u32 = 4294967180;
pub const CX_EC_INFINITE_POINT: u32 = 4294967105;
pub const CX_EC_INVALID_POINT: u32 = 4294967202;
pub const CX_EC_INVALID_CURVE: u32 = 4294967203;
pub const BOLOS_APPNAME_MAX_SIZE_B: u32 = 32;
pub const BOLOS_APPVERSION_MAX_SIZE_B: u32 = 16;
pub const BOLOS_TAG_APPNAME: u32 = 1;
pub const BOLOS_TAG_APPVERSION: u32 = 2;
pub const BOLOS_TAG_ICON: u32 = 3;
pub const BOLOS_TAG_DERIVEPATH: u32 = 4;
pub const BOLOS_TAG_DATA_SIZE: u32 = 5;
pub const BOLOS_TAG_DEPENDENCY: u32 = 6;
pub const BOLOS_TAG_USER_TAG: u32 = 32;
pub const OS_REGISTRY_GET_TAG_OFFSET_COMPARE_WITH_BUFFER: u32 = 2147483648;
pub const OS_REGISTRY_GET_TAG_OFFSET_GET_LENGTH: u32 = 1073741824;
pub const ERR_IOL_RANGE: u32 = 4096;
pub const ERR_TSK_RANGE: u32 = 8192;
pub const ERR_CRY_RANGE: u32 = 12288;
pub const ERR_PAR_RANGE: u32 = 16384;
pub const ERR_SEC_RANGE: u32 = 20480;
pub const ERR_APD_RANGE: u32 = 24576;
pub const ERR_MUI_RANGE: u32 = 40960;
pub const ERR_APP_RANGE_01: u32 = 45056;
pub const ERR_APP_RANGE_02: u32 = 49152;
pub const ERR_APP_RANGE_03: u32 = 53248;
pub const ERR_APP_RANGE_04: u32 = 57344;
pub const ERR_GEN_SUB_01: u32 = 256;
pub const ERR_GEN_SUB_02: u32 = 512;
pub const ERR_GEN_SUB_03: u32 = 768;
pub const ERR_GEN_SUB_04: u32 = 1024;
pub const ERR_GEN_SUB_05: u32 = 1280;
pub const ERR_GEN_SUB_06: u32 = 1536;
pub const ERR_GEN_SUB_07: u32 = 1792;
pub const ERR_GEN_SUB_08: u32 = 2048;
pub const ERR_GEN_SUB_09: u32 = 2304;
pub const ERR_GEN_SUB_0D: u32 = 3328;
pub const ERR_GEN_SUB_0E: u32 = 3584;
pub const ERR_IOL_OFW: u32 = 4352;
pub const ERR_IOL_HDR: u32 = 4608;
pub const ERR_IOL_STA: u32 = 4864;
pub const ERR_IOL_RST: u32 = 5120;
pub const ERR_TSK_STC: u32 = 8448;
pub const ERR_TSK_OWN: u32 = 8704;
pub const ERR_TSK_OFW: u32 = 8960;
pub const ERR_CRY_LEN: u32 = 12544;
pub const ERR_CRY_VAL: u32 = 12800;
pub const ERR_PAR_LEN: u32 = 16640;
pub const ERR_PAR_VAL: u32 = 16896;
pub const ERR_SEC_APP: u32 = 20736;
pub const ERR_SEC_CRC: u32 = 20992;
pub const ERR_SEC_CHK: u32 = 21248;
pub const ERR_SEC_KEY: u32 = 21504;
pub const ERR_SEC_PIN: u32 = 21760;
pub const ERR_SEC_SCP: u32 = 22016;
pub const ERR_SEC_SIG: u32 = 22272;
pub const ERR_SEC_MEM: u32 = 22528;
pub const ERR_SEC_STA: u32 = 22784;
pub const ERR_APD_CLA: u32 = 28160;
pub const ERR_APD_INS: u32 = 27904;
pub const ERR_APD_HDR: u32 = 25856;
pub const ERR_APD_STA: u32 = 26112;
pub const ERR_APD_LEN: u32 = 26368;
pub const ERR_APD_DAT: u32 = 26624;
pub const SWO_SUCCESS: u32 = 36864;
pub const EXCEPTION: u32 = 1;
pub const INVALID_PARAMETER: u32 = 2;
pub const EXCEPTION_SECURITY: u32 = 3;
pub const INVALID_STATE: u32 = 4;
pub const EXCEPTION_IO_RESET: u32 = 5;
pub const NOT_ENOUGH_SPACE: u32 = 6;
pub const EXCEPTION_OVERFLOW: u32 = 7;
pub const INVALID_CRC: u32 = 8;
pub const INVALID_CHECKSUM: u32 = 9;
pub const INVALID_COUNTER: u32 = 10;
pub const NOT_SUPPORTED: u32 = 11;
pub const TIMEOUT: u32 = 12;
pub const EXCEPTION_PIC: u32 = 13;
pub const EXCEPTION_APPEXIT: u32 = 14;
pub const EXCEPTION_IO_OVERFLOW: u32 = 15;
pub const EXCEPTION_IO_HEADER: u32 = 16;
pub const EXCEPTION_IO_STATE: u32 = 17;
pub const EXCEPTION_CXPORT: u32 = 18;
pub const EXCEPTION_SYSTEM: u32 = 19;
pub const _JBLEN: u32 = 23;
pub const CX_LAST: u32 = 1;
pub const CX_SIG_MODE: u32 = 2;
pub const CX_MASK_SIGCRYPT: u32 = 6;
pub const CX_ENCRYPT: u32 = 4;
pub const CX_DECRYPT: u32 = 0;
pub const CX_SIGN: u32 = 6;
pub const CX_VERIFY: u32 = 2;
pub const CX_MASK_PAD: u32 = 56;
pub const CX_PAD_NONE: u32 = 0;
pub const CX_PAD_ISO9797M1: u32 = 8;
pub const CX_PAD_ISO9797M2: u32 = 16;
pub const CX_PAD_PKCS1_1o5: u32 = 24;
pub const CX_PAD_PKCS1_PSS: u32 = 32;
pub const CX_PAD_PKCS1_OAEP: u32 = 40;
pub const CX_MASK_CHAIN: u32 = 448;
pub const CX_CHAIN_ECB: u32 = 0;
pub const CX_CHAIN_CBC: u32 = 64;
pub const CX_CHAIN_CTR: u32 = 128;
pub const CX_CHAIN_CFB: u32 = 192;
pub const CX_CHAIN_OFB: u32 = 256;
pub const CX_MASK_ECC_VARIANT: u32 = 448;
pub const CX_NO_CANONICAL: u32 = 64;
pub const CX_MASK_RND: u32 = 3584;
pub const CX_RND_PRNG: u32 = 512;
pub const CX_RND_TRNG: u32 = 1024;
pub const CX_RND_RFC6979: u32 = 1536;
pub const CX_RND_PROVIDED: u32 = 2048;
pub const CX_MASK_EC: u32 = 28672;
pub const CX_ECSCHNORR_BIP0340: u32 = 0;
pub const CX_ECDH_POINT: u32 = 4096;
pub const CX_ECDH_X: u32 = 8192;
pub const CX_ECSCHNORR_ISO14888_XY: u32 = 12288;
pub const CX_ECSCHNORR_ISO14888_X: u32 = 16384;
pub const CX_ECSCHNORR_BSI03111: u32 = 20480;
pub const CX_ECSCHNORR_LIBSECP: u32 = 24576;
pub const CX_ECSCHNORR_Z: u32 = 28672;
pub const CX_NO_REINIT: u32 = 32768;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const CX_HASH_MAX_BLOCK_COUNT: u32 = 65535;
pub const CX_BN_WORD_ALIGNEMENT: u32 = 16;
pub const CX_BN_FLAG_UNSET: u32 = 128;
pub const CX_MAX_DOMAIN_LENGTH: u32 = 66;
pub const CX_ECCINFO_PARITY_ODD: u32 = 1;
pub const CX_ECCINFO_xGTn: u32 = 2;
pub const BOLOS_UX_ONBOARDING_ALGORITHM_BIP39: u32 = 1;
pub const BOLOS_UX_ONBOARDING_ALGORITHM_ELECTRUM: u32 = 2;
pub const HDW_NORMAL: u32 = 0;
pub const HDW_ED25519_SLIP10: u32 = 1;
pub const HDW_SLIP21: u32 = 2;
pub const CX_APILEVEL: u32 = 12;
pub const CX_COMPAT_APILEVEL: u32 = 12;
pub const CXPORT_ED_DES: u32 = 1;
pub const CXPORT_ED_AES: u32 = 2;
pub const CXPORT_ED_RSA: u32 = 4;
pub const BLE_CMD_APDU: u32 = 5;
pub const BLE_CHUNK_LENGTH: u32 = 20;
pub const M24SR_CHUNK_LENGTH: u32 = 246;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT: u32 = 1;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_REQBLE: u32 = 1;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_RECOVERY: u32 = 2;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FLASHBACK: u32 = 4;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_USB: u32 = 1;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_BLE: u32 = 2;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_TOUCH: u32 = 4;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_BUTTON_COUNT: u32 = 240;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_BUTTON_COUNT_POS: u32 = 4;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_SCREEN_MASK: u32 = 3840;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_NO_SCREEN: u32 = 0;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_SCREEN_BIG: u32 = 256;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_SCREEN_SML: u32 = 512;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_SCREEN_SSD1312: u32 = 768;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_LEDRGB: u32 = 4096;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_BATTERY: u32 = 8;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_ISET_MASK: u32 = 4026531840;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_ISET_BASIC: u32 = 0;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_ISET_MCUSEC: u32 = 268435456;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_ISET_MCUBL: u32 = 536870912;
pub const SEPROXYHAL_TAG_BLE_SECURITY_DB_EVENT: u32 = 2;
pub const SEPROXYHAL_TAG_BLE_SECURITY_DB_LOADED_EVENT: u32 = 0;
pub const SEPROXYHAL_TAG_BLE_SECURITY_DB_DUMP_EVENT: u32 = 1;
pub const SEPROXYHAL_TAG_BLE_WRITE_REQUEST_EVENT: u32 = 3;
pub const SEPROXYHAL_TAG_BLE_READ_REQUEST_EVENT: u32 = 4;
pub const SEPROXYHAL_TAG_BUTTON_PUSH_EVENT: u32 = 5;
pub const SEPROXYHAL_TAG_BUTTON_PUSH_ID_MASK: u32 = 254;
pub const SEPROXYHAL_TAG_BUTTON_PUSH_INTERVAL_MS: u32 = 100;
pub const SEPROXYHAL_TAG_NFC_FIELD_DETECTION_EVENT: u32 = 6;
pub const SEPROXYHAL_TAG_NFC_APDU_RECEIVED_EVENT: u32 = 7;
pub const SEPROXYHAL_TAG_BATTERY_NOTIFICATION_EVENT: u32 = 8;
pub const SEPROXYHAL_TAG_M24SR_GPO_CHANGE_EVENT: u32 = 9;
pub const SEPROXYHAL_TAG_M24SR_RESPONSE_APDU_EVENT: u32 = 10;
pub const SEPROXYHAL_TAG_BLE_NOTIFY_INDICATE_EVENT: u32 = 11;
pub const SEPROXYHAL_TAG_FINGER_EVENT: u32 = 12;
pub const SEPROXYHAL_TAG_FINGER_EVENT_TOUCH: u32 = 1;
pub const SEPROXYHAL_TAG_FINGER_EVENT_RELEASE: u32 = 2;
pub const SEPROXYHAL_TAG_DISPLAY_PROCESSED_EVENT: u32 = 13;
pub const SEPROXYHAL_TAG_TICKER_EVENT: u32 = 14;
pub const SEPROXYHAL_TAG_USB_EVENT: u32 = 15;
pub const SEPROXYHAL_TAG_USB_EVENT_RESET: u32 = 1;
pub const SEPROXYHAL_TAG_USB_EVENT_SOF: u32 = 2;
pub const SEPROXYHAL_TAG_USB_EVENT_SUSPENDED: u32 = 4;
pub const SEPROXYHAL_TAG_USB_EVENT_RESUMED: u32 = 8;
pub const SEPROXYHAL_TAG_USB_EP_XFER_EVENT: u32 = 16;
pub const SEPROXYHAL_TAG_USB_EP_XFER_SETUP: u32 = 1;
pub const SEPROXYHAL_TAG_USB_EP_XFER_IN: u32 = 2;
pub const SEPROXYHAL_TAG_USB_EP_XFER_OUT: u32 = 4;
pub const SEPROXYHAL_TAG_BLE_CONNECTION_EVENT: u32 = 17;
pub const SEPROXYHAL_TAG_UNSEC_CHUNK_EVENT: u32 = 18;
pub const SEPROXYHAL_TAG_ACK_LINK_SPEED: u32 = 19;
pub const SEPROXYHAL_TAG_BLUENRG_RECV_EVENT: u32 = 20;
pub const SEPROXYHAL_TAG_STATUS_EVENT: u32 = 21;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_CHARGING: u32 = 1;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_USB_ON: u32 = 2;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_BLE_ON: u32 = 4;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_USB_POWERED: u32 = 8;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_CHARGING_ISSUE: u32 = 16;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_TEMPERATURE_ISSUE: u32 = 32;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_BATTERY_ISSUE: u32 = 64;
pub const SEPROXYHAL_TAG_CAPDU_EVENT: u32 = 22;
pub const SEPROXYHAL_TAG_I2C_EVENT: u32 = 23;
pub const SEPROXYHAL_TAG_I2C_EVENT_KIND_READ: u32 = 1;
pub const SEPROXYHAL_TAG_I2C_EVENT_KIND_WRITE: u32 = 2;
pub const SEPROXYHAL_TAG_BLE_RECV_EVENT: u32 = 24;
pub const SEPROXYHAL_TAG_BOOTLOADER_RAPDU_EVENT: u32 = 25;
pub const SEPROXYHAL_TAG_UX_EVENT: u32 = 26;
pub const SEPROXYHAL_TAG_UNSEC_CHUNK_READ: u32 = 50;
pub const SEPROXYHAL_TAG_UNSEC_CHUNK_READ_EXT: u32 = 51;
pub const SEPROXYHAL_TAG_BLE_SEND: u32 = 56;
pub const SEPROXYHAL_TAG_SET_SCREEN_CONFIG: u32 = 62;
pub const SEPROXYHAL_TAG_SET_LINK_PROP: u32 = 63;
pub const SEPROXYHAL_TAG_BLUENRG_SEND: u32 = 64;
pub const SEPROXYHAL_TAG_BLE_DEFINE_GENERIC_SETTING: u32 = 65;
pub const SEPROXYHAL_TAG_BLE_DEFINE_SERVICE_SETTING: u32 = 66;
pub const SEPROXYHAL_TAG_NFC_DEFINE_SERVICE_SETTING: u32 = 67;
pub const SEPROXYHAL_TAG_BLE_RADIO_POWER: u32 = 68;
pub const SEPROXYHAL_TAG_BLE_RADIO_POWER_ACTION_ON: u32 = 2;
pub const SEPROXYHAL_TAG_BLE_RADIO_POWER_ACTION_DBWIPE: u32 = 4;
pub const SEPROXYHAL_TAG_BLE_RADIO_POWER_FACTORY_TEST: u32 = 64;
pub const SEPROXYHAL_TAG_NFC_RADIO_POWER: u32 = 69;
pub const SEPROXYHAL_TAG_SE_POWER_OFF: u32 = 70;
pub const SEPROXYHAL_TAG_BLE_SECURITY_DB: u32 = 72;
pub const SEPROXYHAL_TAG_BLE_SECURITY_DB_CMD_READ: u32 = 1;
pub const SEPROXYHAL_TAG_BLE_SECURITY_DB_CMD_WRITE: u32 = 2;
pub const SEPROXYHAL_TAG_BATTERY_CHARGE: u32 = 73;
pub const SEPROXYHAL_TAG_DEVICE_OFF: u32 = 75;
pub const SEPROXYHAL_TAG_MORE_TIME: u32 = 76;
pub const SEPROXYHAL_TAG_M24SR_C_APDU: u32 = 77;
pub const SEPROXYHAL_TAG_SET_TICKER_INTERVAL: u32 = 78;
pub const SEPROXYHAL_TAG_USB_CONFIG: u32 = 79;
pub const SEPROXYHAL_TAG_USB_CONFIG_CONNECT: u32 = 1;
pub const SEPROXYHAL_TAG_USB_CONFIG_DISCONNECT: u32 = 2;
pub const SEPROXYHAL_TAG_USB_CONFIG_ADDR: u32 = 3;
pub const SEPROXYHAL_TAG_USB_CONFIG_ENDPOINTS: u32 = 4;
pub const SEPROXYHAL_TAG_USB_CONFIG_TYPE_DISABLED: u32 = 0;
pub const SEPROXYHAL_TAG_USB_CONFIG_TYPE_CONTROL: u32 = 1;
pub const SEPROXYHAL_TAG_USB_CONFIG_TYPE_INTERRUPT: u32 = 2;
pub const SEPROXYHAL_TAG_USB_CONFIG_TYPE_BULK: u32 = 3;
pub const SEPROXYHAL_TAG_USB_CONFIG_TYPE_ISOCHRONOUS: u32 = 4;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE: u32 = 80;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_SETUP: u32 = 16;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_IN: u32 = 32;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_OUT: u32 = 48;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_STALL: u32 = 64;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_UNSTALL: u32 = 128;
pub const SEPROXYHAL_TAG_SET_LED: u32 = 81;
pub const SEPROXYHAL_TAG_REQUEST_STATUS: u32 = 82;
pub const SEPROXYHAL_TAG_RAPDU: u32 = 83;
pub const SEPROXYHAL_TAG_I2C_XFER: u32 = 84;
pub const SEPROXYHAL_TAG_UX_CMD: u32 = 93;
pub const SEPROXYHAL_TAG_UX_CMD_BLE_DISABLE_ADV: u32 = 0;
pub const SEPROXYHAL_TAG_UX_CMD_BLE_ENABLE_ADV: u32 = 1;
pub const SEPROXYHAL_TAG_UX_CMD_BLE_RESET_PAIRINGS: u32 = 2;
pub const SEPROXYHAL_TAG_UX_CMD_REDISPLAY: u32 = 3;
pub const SEPROXYHAL_TAG_PRINTF: u32 = 95;
pub const SEPROXYHAL_TAG_DBG_SCREEN_DISPLAY_STATUS: u32 = 94;
pub const SEPROXYHAL_TAG_STATUS_MASK: u32 = 96;
pub const SEPROXYHAL_TAG_GENERAL_STATUS: u32 = 96;
pub const SEPROXYHAL_TAG_GENERAL_STATUS_LAST_COMMAND: u32 = 0;
pub const SEPROXYHAL_TAG_PAIRING_STATUS: u32 = 97;
pub const SEPROXYHAL_TAG_BLE_READ_RESPONSE_STATUS: u32 = 98;
pub const SEPROXYHAL_TAG_NFC_READ_RESPONSE_STATUS: u32 = 99;
pub const SEPROXYHAL_TAG_BLE_NOTIFY_INDICATE_STATUS: u32 = 100;
pub const SEPROXYHAL_TAG_SCREEN_DISPLAY_STATUS: u32 = 101;
pub const SEPROXYHAL_TAG_PRINTF_STATUS: u32 = 102;
pub const SEPROXYHAL_TAG_SET_LINK_SPEED: u32 = 103;
pub const SEPROXYHAL_TAG_SCREEN_ANIMATION_STATUS: u32 = 104;
pub const SEPROXYHAL_TAG_SCREEN_ANIMATION_STATUS_VERTICAL_SPLIT_SLIDE: u32 = 0;
pub const SEPROXYHAL_TAG_BOOTLOADER_CAPDU_STATUS: u32 = 106;
pub const IO_CACHE: u32 = 1;
pub const NO_TIMEOUT: u32 = 0;
pub const CX_AES_BLOCK_SIZE: u32 = 16;
pub const CX_DES_BLOCK_SIZE: u32 = 8;
pub const CX_RIPEMD160_SIZE: u32 = 20;
pub const CX_SHA224_SIZE: u32 = 28;
pub const CX_SHA256_SIZE: u32 = 32;
pub const CX_SHA384_SIZE: u32 = 48;
pub const CX_SHA512_SIZE: u32 = 64;
pub const ROWS: u32 = 8;
pub const COLS1024: u32 = 16;
pub const SIZE1024: u32 = 128;
pub const CX_CRC16_INIT: u32 = 65535;
extern "C" {
    pub fn os_endorsement_get_code_hash(buffer: *mut core::ffi::c_uchar) -> core::ffi::c_uint;
}
extern "C" {
    pub fn os_endorsement_get_public_key(
        index: core::ffi::c_uchar,
        buffer: *mut core::ffi::c_uchar,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn os_endorsement_get_public_key_certificate(
        index: core::ffi::c_uchar,
        buffer: *mut core::ffi::c_uchar,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn os_endorsement_key1_get_app_secret(buffer: *mut core::ffi::c_uchar)
        -> core::ffi::c_uint;
}
extern "C" {
    pub fn os_endorsement_key1_sign_data(
        src: *mut core::ffi::c_uchar,
        srcLength: core::ffi::c_uint,
        signature: *mut core::ffi::c_uchar,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn os_endorsement_key2_derive_sign_data(
        src: *mut core::ffi::c_uchar,
        srcLength: core::ffi::c_uint,
        signature: *mut core::ffi::c_uchar,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn halt();
}
extern "C" {
    pub fn os_parse_bertlv(
        mem: *mut core::ffi::c_uchar,
        mem_len: core::ffi::c_uint,
        tlv_instance_offset: *mut core::ffi::c_uint,
        tag: core::ffi::c_uint,
        offset: core::ffi::c_uint,
        buffer: *mut *mut core::ffi::c_void,
        maxlength: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
pub type bolos_bool_t = core::ffi::c_char;
pub type bolos_task_status_t = core::ffi::c_uchar;
pub const TASK_BOLOS: task_unsecure_id_e = 0;
pub const TASK_SYSCALL: task_unsecure_id_e = 1;
pub const TASK_USERTASKS_START: task_unsecure_id_e = 2;
pub const TASK_USER: task_unsecure_id_e = 2;
pub const TASK_SUBTASKS_START: task_unsecure_id_e = 3;
pub const TASK_SUBTASK_0: task_unsecure_id_e = 3;
pub const TASK_BOLOS_UX: task_unsecure_id_e = 4;
pub const TASK_MAXCOUNT: task_unsecure_id_e = 5;
pub type task_unsecure_id_e = core::ffi::c_uchar;
extern "C" {
    pub fn os_sched_exec(app_idx: core::ffi::c_uint);
}
extern "C" {
    pub fn os_sched_exit(exit_code: bolos_task_status_t);
}
extern "C" {
    pub fn os_sched_is_running(task_idx: core::ffi::c_uint) -> bolos_bool_t;
}
extern "C" {
    pub fn os_sched_last_status(task_idx: core::ffi::c_uint) -> bolos_task_status_t;
}
extern "C" {
    pub fn os_sched_yield(status: bolos_task_status_t);
}
extern "C" {
    pub fn os_sched_switch(task_idx: core::ffi::c_uint, status: bolos_task_status_t);
}
extern "C" {
    pub fn os_sched_current_task() -> core::ffi::c_uint;
}
extern "C" {
    pub fn os_sched_create(
        main: *mut core::ffi::c_void,
        nvram: *mut core::ffi::c_void,
        nvram_length: core::ffi::c_uint,
        ram0: *mut core::ffi::c_void,
        ram0_length: core::ffi::c_uint,
        stack: *mut core::ffi::c_void,
        stack_length: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn os_sched_kill(taskidx: core::ffi::c_uint);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bolos_ux_asynch_callback_t {
    pub asynchmodal_end_callback:
        ::core::option::Option<unsafe extern "C" fn(ux_status: core::ffi::c_uint)>,
}
extern "C" {
    pub static mut G_io_asynch_ux_callback: bolos_ux_asynch_callback_t;
}
extern "C" {
    pub fn os_flags() -> core::ffi::c_uint;
}
extern "C" {
    pub fn os_version(
        version: *mut core::ffi::c_uchar,
        maxlength: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn os_serial(
        serial: *mut core::ffi::c_uchar,
        maxlength: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn os_seph_features() -> core::ffi::c_uint;
}
extern "C" {
    pub fn os_seph_version(
        version: *mut core::ffi::c_uchar,
        maxlength: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn os_bootloader_version(
        version: *mut core::ffi::c_uchar,
        maxlength: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn os_get_sn(buffer: *mut core::ffi::c_uchar) -> core::ffi::c_uint;
}
extern "C" {
    pub fn get_api_level() -> core::ffi::c_uint;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct apdu_buffer_s {
    pub buf: *mut u8,
    pub len: u16,
}
impl Default for apdu_buffer_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type apdu_buffer_t = apdu_buffer_s;
extern "C" {
    pub static mut G_io_apdu_buffer: [core::ffi::c_uchar; 260usize];
}
extern "C" {
    pub fn io_exchange(
        channel_and_flags: core::ffi::c_uchar,
        tx_len: core::ffi::c_ushort,
    ) -> core::ffi::c_ushort;
}
pub const IO_APDU_MEDIA_NONE: io_apdu_media_t = 0;
pub const IO_APDU_MEDIA_USB_HID: io_apdu_media_t = 1;
pub const IO_APDU_MEDIA_BLE: io_apdu_media_t = 2;
pub const IO_APDU_MEDIA_NFC: io_apdu_media_t = 3;
pub const IO_APDU_MEDIA_USB_CCID: io_apdu_media_t = 4;
pub const IO_APDU_MEDIA_USB_WEBUSB: io_apdu_media_t = 5;
pub const IO_APDU_MEDIA_RAW: io_apdu_media_t = 6;
pub const IO_APDU_MEDIA_U2F: io_apdu_media_t = 7;
pub type io_apdu_media_t = core::ffi::c_uchar;
extern "C" {
    pub static mut G_io_usb_ep_buffer: [core::ffi::c_uchar; 64usize];
}
extern "C" {
    pub fn io_event(channel: core::ffi::c_uchar) -> core::ffi::c_uchar;
}
extern "C" {
    pub fn os_lib_call(call_parameters: *mut core::ffi::c_uint);
}
extern "C" {
    pub fn os_lib_end();
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct meminfo_s {
    pub free_nvram_size: core::ffi::c_uint,
    pub appMemory: core::ffi::c_uint,
    pub systemSize: core::ffi::c_uint,
    pub slots: core::ffi::c_uint,
}
pub type meminfo_t = meminfo_s;
extern "C" {
    pub fn os_get_memory_info(meminfo: *mut meminfo_t);
}
extern "C" {
    pub fn nvm_write(
        dst_adr: *mut core::ffi::c_void,
        src_adr: *mut core::ffi::c_void,
        src_len: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn nvm_erase(dst_adr: *mut core::ffi::c_void, len: core::ffi::c_uint);
}
extern "C" {
    pub fn nvm_write_page(page_adr: core::ffi::c_uint);
}
extern "C" {
    pub fn nvm_erase_page(page_adr: core::ffi::c_uint);
}
extern "C" {
    pub fn os_perso_erase_all();
}
extern "C" {
    pub fn pic(linked_address: *mut core::ffi::c_void) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn pic_internal(link_address: *mut core::ffi::c_void) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn os_perso_set_pin(
        identity: core::ffi::c_uint,
        pin: *mut core::ffi::c_uchar,
        length: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn os_perso_set_current_identity_pin(
        pin: *mut core::ffi::c_uchar,
        length: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn os_global_pin_is_validated() -> bolos_bool_t;
}
extern "C" {
    pub fn os_global_pin_check(
        pin_buffer: *mut core::ffi::c_uchar,
        pin_length: core::ffi::c_uchar,
    ) -> bolos_bool_t;
}
extern "C" {
    pub fn os_global_pin_invalidate();
}
extern "C" {
    pub fn os_global_pin_retries() -> core::ffi::c_uint;
}
pub type size_t = core::ffi::c_uint;
pub type cx_err_t = u32;
extern "C" {
    pub fn cx_get_random_bytes(buffer: *mut core::ffi::c_void, len: size_t) -> cx_err_t;
}
pub type appmain_t = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct application_s {
    pub nvram_begin: *mut core::ffi::c_uchar,
    pub nvram_end: *mut core::ffi::c_uchar,
    pub main: appmain_t,
    pub flags: core::ffi::c_uint,
    pub code_length: core::ffi::c_uint,
    pub data_length: core::ffi::c_uint,
    pub params_length: core::ffi::c_uint,
    pub sha256_code_data: [core::ffi::c_uchar; 32usize],
    pub sha256_full: [core::ffi::c_uchar; 32usize],
}
impl Default for application_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type application_t = application_s;
extern "C" {
    pub fn os_registry_get_tag(
        app_idx: core::ffi::c_uint,
        tlvoffset: *mut core::ffi::c_uint,
        tag: core::ffi::c_uint,
        value_offset: core::ffi::c_uint,
        buffer: *mut core::ffi::c_void,
        maxlength: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn os_registry_get_current_app_tag(
        tag: core::ffi::c_uint,
        buffer: *mut core::ffi::c_uchar,
        maxlen: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn os_registry_delete_app_and_dependees(app_idx: core::ffi::c_uint);
}
extern "C" {
    pub fn os_registry_delete_all_apps();
}
extern "C" {
    pub fn os_registry_count() -> core::ffi::c_uint;
}
extern "C" {
    pub fn os_registry_get(app_idx: core::ffi::c_uint, out_application_entry: *mut application_t);
}
pub const ERR_GEN_ID_01: generic_identifiers = 1;
pub const ERR_GEN_ID_02: generic_identifiers = 2;
pub const ERR_GEN_ID_03: generic_identifiers = 3;
pub const ERR_GEN_ID_04: generic_identifiers = 4;
pub const ERR_GEN_ID_05: generic_identifiers = 5;
pub const ERR_GEN_ID_06: generic_identifiers = 6;
pub const ERR_GEN_ID_07: generic_identifiers = 7;
pub const ERR_GEN_ID_08: generic_identifiers = 8;
pub const ERR_GEN_ID_09: generic_identifiers = 9;
pub const ERR_GEN_ID_0A: generic_identifiers = 10;
pub const ERR_GEN_ID_0B: generic_identifiers = 11;
pub const ERR_GEN_ID_0C: generic_identifiers = 12;
pub const ERR_GEN_ID_0D: generic_identifiers = 13;
pub const ERR_GEN_ID_0E: generic_identifiers = 14;
pub const ERR_GEN_ID_0F: generic_identifiers = 15;
pub const ERR_GEN_ID_10: generic_identifiers = 16;
pub const ERR_GEN_ID_11: generic_identifiers = 17;
pub const ERR_GEN_ID_12: generic_identifiers = 18;
pub const ERR_GEN_ID_13: generic_identifiers = 19;
pub const ERR_GEN_ID_14: generic_identifiers = 20;
pub const ERR_GEN_ID_15: generic_identifiers = 21;
pub const ERR_GEN_ID_16: generic_identifiers = 22;
pub const ERR_GEN_ID_17: generic_identifiers = 23;
pub const ERR_GEN_ID_18: generic_identifiers = 24;
pub const ERR_GEN_ID_19: generic_identifiers = 25;
pub const ERR_GEN_ID_1A: generic_identifiers = 26;
pub const ERR_GEN_ID_1B: generic_identifiers = 27;
pub const ERR_GEN_ID_1C: generic_identifiers = 28;
pub const ERR_GEN_ID_1D: generic_identifiers = 29;
pub const ERR_GEN_ID_1E: generic_identifiers = 30;
pub const ERR_GEN_ID_1F: generic_identifiers = 31;
pub const ERR_GEN_ID_20: generic_identifiers = 32;
pub const ERR_GEN_ID_21: generic_identifiers = 33;
pub const ERR_GEN_ID_22: generic_identifiers = 34;
pub const ERR_GEN_ID_23: generic_identifiers = 35;
pub const ERR_GEN_ID_24: generic_identifiers = 36;
pub const ERR_GEN_ID_25: generic_identifiers = 37;
pub const ERR_GEN_ID_26: generic_identifiers = 38;
pub const ERR_GEN_ID_27: generic_identifiers = 39;
pub const ERR_GEN_ID_28: generic_identifiers = 40;
pub const ERR_GEN_ID_29: generic_identifiers = 41;
pub const ERR_GEN_ID_2A: generic_identifiers = 42;
pub const ERR_GEN_ID_2B: generic_identifiers = 43;
pub type generic_identifiers = core::ffi::c_uchar;
pub type exception_t = core::ffi::c_ushort;
pub type try_context_t = try_context_s;
pub type jmp_buf = [core::ffi::c_int; 23usize];
extern "C" {
    pub fn longjmp(__jmpb: *mut core::ffi::c_int, __retval: core::ffi::c_int);
}
extern "C" {
    pub fn setjmp(__jmpb: *mut core::ffi::c_int) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct try_context_s {
    pub jmp_buf: jmp_buf,
    pub previous: *mut try_context_t,
    pub ex: exception_t,
}
impl Default for try_context_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn try_context_get() -> *mut try_context_t;
}
extern "C" {
    pub fn try_context_set(context: *mut try_context_t) -> *mut try_context_t;
}
extern "C" {
    pub fn os_longjmp(exception: core::ffi::c_uint);
}
pub type uint64bits_t = u64;
pub const CX_NONE: cx_md_e = 0;
pub const CX_RIPEMD160: cx_md_e = 1;
pub const CX_SHA224: cx_md_e = 2;
pub const CX_SHA256: cx_md_e = 3;
pub const CX_SHA384: cx_md_e = 4;
pub const CX_SHA512: cx_md_e = 5;
pub const CX_KECCAK: cx_md_e = 6;
pub const CX_SHA3: cx_md_e = 7;
pub const DEPRECATED_0: cx_md_e = 8;
pub const CX_BLAKE2B: cx_md_e = 9;
pub const CX_SHAKE128: cx_md_e = 10;
pub const CX_SHAKE256: cx_md_e = 11;
pub const CX_SHA3_256: cx_md_e = 12;
pub const CX_SHA3_512: cx_md_e = 13;
pub type cx_md_e = core::ffi::c_uchar;
pub use self::cx_md_e as cx_md_t;
pub type cx_hash_t = cx_hash_header_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_hash_info_t {
    pub md_type: cx_md_t,
    pub output_size: size_t,
    pub block_size: size_t,
    pub init_func: ::core::option::Option<unsafe extern "C" fn(ctx: *mut cx_hash_t) -> cx_err_t>,
    pub update_func: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut cx_hash_t, data: *const u8, len: size_t) -> cx_err_t,
    >,
    pub finish_func: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut cx_hash_t, digest: *mut u8) -> cx_err_t,
    >,
    pub init_ex_func: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut cx_hash_t, output_size: size_t) -> cx_err_t,
    >,
    pub output_size_func:
        ::core::option::Option<unsafe extern "C" fn(ctx: *const cx_hash_t) -> size_t>,
}
impl Default for cx_hash_info_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_hash_header_s {
    pub info: *const cx_hash_info_t,
    pub counter: u32,
}
impl Default for cx_hash_header_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn cx_hash_get_size(ctx: *const cx_hash_t) -> size_t;
}
extern "C" {
    pub fn cx_hash_no_throw(
        hash: *mut cx_hash_t,
        mode: u32,
        in_: *const u8,
        len: size_t,
        out: *mut u8,
        out_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_hash_init(hash: *mut cx_hash_t, hash_id: cx_md_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_hash_init_ex(hash: *mut cx_hash_t, hash_id: cx_md_t, output_size: size_t)
        -> cx_err_t;
}
extern "C" {
    pub fn cx_hash_update(hash: *mut cx_hash_t, in_: *const u8, in_len: size_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_hash_final(hash: *mut cx_hash_t, digest: *mut u8) -> cx_err_t;
}
pub type cx_bn_t = u32;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cx_bn_mont_ctx_t {
    pub n: cx_bn_t,
    pub h: cx_bn_t,
}
extern "C" {
    pub fn cx_bn_lock(word_nbytes: size_t, flags: u32) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_unlock() -> u32;
}
extern "C" {
    pub fn cx_bn_is_locked() -> bool;
}
extern "C" {
    pub fn cx_bn_locked() -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_alloc(x: *mut cx_bn_t, nbytes: size_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_alloc_init(
        x: *mut cx_bn_t,
        nbytes: size_t,
        value: *const u8,
        value_nbytes: size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_destroy(x: *mut cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_nbytes(x: cx_bn_t, nbytes: *mut size_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_init(x: cx_bn_t, value: *const u8, value_nbytes: size_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_rand(x: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_copy(a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_set_u32(x: cx_bn_t, n: u32) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_get_u32(x: cx_bn_t, n: *mut u32) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_export(x: cx_bn_t, bytes: *mut u8, nbytes: size_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_cmp(a: cx_bn_t, b: cx_bn_t, diff: *mut core::ffi::c_int) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_cmp_u32(a: cx_bn_t, b: u32, diff: *mut core::ffi::c_int) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_is_odd(n: cx_bn_t, odd: *mut bool) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_xor(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_or(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_and(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_tst_bit(x: cx_bn_t, pos: u32, set: *mut bool) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_set_bit(x: cx_bn_t, pos: u32) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_clr_bit(x: cx_bn_t, pos: u32) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_shr(x: cx_bn_t, n: u32) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_shl(x: cx_bn_t, n: u32) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_cnt_bits(n: cx_bn_t, nbits: *mut u32) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_add(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_sub(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_mul(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_mod_add(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_mod_sub(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_mod_mul(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_reduce(r: cx_bn_t, d: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_mod_sqrt(r: cx_bn_t, a: cx_bn_t, n: cx_bn_t, sign: u32) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_mod_pow_bn(r: cx_bn_t, a: cx_bn_t, e: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_mod_pow(r: cx_bn_t, a: cx_bn_t, e: *const u8, e_len: u32, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_mod_pow2(r: cx_bn_t, a: cx_bn_t, e: *const u8, e_len: u32, n: cx_bn_t)
        -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_mod_invert_nprime(r: cx_bn_t, a: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_mod_u32_invert(r: cx_bn_t, a: u32, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_mont_alloc(ctx: *mut cx_bn_mont_ctx_t, length: size_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_mont_init(ctx: *mut cx_bn_mont_ctx_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_mont_init2(ctx: *mut cx_bn_mont_ctx_t, n: cx_bn_t, h: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_mont_to_montgomery(x: cx_bn_t, z: cx_bn_t, ctx: *const cx_bn_mont_ctx_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_mont_from_montgomery(
        z: cx_bn_t,
        x: cx_bn_t,
        ctx: *const cx_bn_mont_ctx_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_mont_mul(
        r: cx_bn_t,
        a: cx_bn_t,
        b: cx_bn_t,
        ctx: *const cx_bn_mont_ctx_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_mont_pow(
        r: cx_bn_t,
        a: cx_bn_t,
        e: *const u8,
        e_len: u32,
        ctx: *const cx_bn_mont_ctx_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_mont_pow_bn(
        r: cx_bn_t,
        a: cx_bn_t,
        e: cx_bn_t,
        ctx: *const cx_bn_mont_ctx_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_mont_invert_nprime(r: cx_bn_t, a: cx_bn_t, ctx: *const cx_bn_mont_ctx_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_is_prime(n: cx_bn_t, prime: *mut bool) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_next_prime(n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_rng(r: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_gf2_n_mul(
        bn_r: cx_bn_t,
        bn_a: cx_bn_t,
        bn_b: cx_bn_t,
        bn_n: cx_bn_t,
        bn_h: cx_bn_t,
    ) -> cx_err_t;
}
pub const CX_CURVE_NONE: cx_curve_e = 0;
pub const CX_CURVE_WEIERSTRASS_START: cx_curve_e = 32;
pub const CX_CURVE_SECP256K1: cx_curve_e = 33;
pub const CX_CURVE_SECP256R1: cx_curve_e = 34;
pub const CX_CURVE_SECP384R1: cx_curve_e = 35;
pub const CX_CURVE_SECP521R1: cx_curve_e = 36;
pub const CX_CURVE_BrainPoolP256T1: cx_curve_e = 49;
pub const CX_CURVE_BrainPoolP256R1: cx_curve_e = 50;
pub const CX_CURVE_BrainPoolP320T1: cx_curve_e = 51;
pub const CX_CURVE_BrainPoolP320R1: cx_curve_e = 52;
pub const CX_CURVE_BrainPoolP384T1: cx_curve_e = 53;
pub const CX_CURVE_BrainPoolP384R1: cx_curve_e = 54;
pub const CX_CURVE_BrainPoolP512T1: cx_curve_e = 55;
pub const CX_CURVE_BrainPoolP512R1: cx_curve_e = 56;
pub const CX_CURVE_BLS12_381_G1: cx_curve_e = 57;
pub const CX_CURVE_FRP256V1: cx_curve_e = 65;
pub const CX_CURVE_Stark256: cx_curve_e = 81;
pub const CX_CURVE_WEIERSTRASS_END: cx_curve_e = 111;
pub const CX_CURVE_TWISTED_EDWARDS_START: cx_curve_e = 112;
pub const CX_CURVE_Ed25519: cx_curve_e = 113;
pub const CX_CURVE_Ed448: cx_curve_e = 114;
pub const CX_CURVE_TWISTED_EDWARDS_END: cx_curve_e = 127;
pub const CX_CURVE_MONTGOMERY_START: cx_curve_e = 128;
pub const CX_CURVE_Curve25519: cx_curve_e = 129;
pub const CX_CURVE_Curve448: cx_curve_e = 130;
pub const CX_CURVE_MONTGOMERY_END: cx_curve_e = 143;
pub type cx_curve_e = core::ffi::c_uchar;
pub use self::cx_curve_e as cx_curve_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_curve_weierstrass_s {
    pub curve: cx_curve_t,
    pub bit_size: core::ffi::c_uint,
    pub length: core::ffi::c_uint,
    pub a: *const u8,
    pub b: *const u8,
    pub p: *const u8,
    pub Gx: *const u8,
    pub Gy: *const u8,
    pub n: *const u8,
    pub h: *const u8,
    pub Hn: *const u8,
    pub Hp: *const u8,
}
impl Default for cx_curve_weierstrass_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_curve_weierstrass_t = cx_curve_weierstrass_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_curve_twisted_edwards_s {
    pub curve: cx_curve_t,
    pub bit_size: core::ffi::c_uint,
    pub length: core::ffi::c_uint,
    pub a: *const u8,
    pub b: *const u8,
    pub p: *const u8,
    pub Gx: *const u8,
    pub Gy: *const u8,
    pub n: *const u8,
    pub h: *const u8,
    pub Hn: *const u8,
    pub Hp: *const u8,
}
impl Default for cx_curve_twisted_edwards_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_curve_twisted_edwards_t = cx_curve_twisted_edwards_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_curve_montgomery_s {
    pub curve: cx_curve_t,
    pub bit_size: core::ffi::c_uint,
    pub length: core::ffi::c_uint,
    pub a: *const u8,
    pub b: *const u8,
    pub p: *const u8,
    pub Gx: *const u8,
    pub Gy: *const u8,
    pub n: *const u8,
    pub h: *const u8,
    pub Hn: *const u8,
    pub Hp: *const u8,
}
impl Default for cx_curve_montgomery_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_curve_montgomery_t = cx_curve_montgomery_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_curve_domain_s {
    pub curve: cx_curve_t,
    pub bit_size: core::ffi::c_uint,
    pub length: core::ffi::c_uint,
    pub a: *const u8,
    pub b: *const u8,
    pub p: *const u8,
    pub Gx: *const u8,
    pub Gy: *const u8,
    pub n: *const u8,
    pub h: *const u8,
    pub Hn: *const u8,
    pub Hp: *const u8,
}
impl Default for cx_curve_domain_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_curve_domain_t = cx_curve_domain_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_ec_point_s {
    pub curve: cx_curve_t,
    pub x: cx_bn_t,
    pub y: cx_bn_t,
    pub z: cx_bn_t,
}
impl Default for cx_ec_point_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_ecpoint_t = cx_ec_point_s;
pub const CX_CURVE_PARAM_NONE: cx_curve_dom_param_s = 0;
pub const CX_CURVE_PARAM_A: cx_curve_dom_param_s = 1;
pub const CX_CURVE_PARAM_B: cx_curve_dom_param_s = 2;
pub const CX_CURVE_PARAM_Field: cx_curve_dom_param_s = 3;
pub const CX_CURVE_PARAM_Gx: cx_curve_dom_param_s = 4;
pub const CX_CURVE_PARAM_Gy: cx_curve_dom_param_s = 5;
pub const CX_CURVE_PARAM_Order: cx_curve_dom_param_s = 6;
pub const CX_CURVE_PARAM_Cofactor: cx_curve_dom_param_s = 7;
pub type cx_curve_dom_param_s = core::ffi::c_uchar;
pub use self::cx_curve_dom_param_s as cx_curve_dom_param_t;
extern "C" {
    pub fn cx_ecdomain_size(curve: cx_curve_t, length: *mut size_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecdomain_parameters_length(cv: cx_curve_t, length: *mut size_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecdomain_parameter(
        cv: cx_curve_t,
        id: cx_curve_dom_param_t,
        p: *mut u8,
        p_len: u32,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecdomain_parameter_bn(
        cv: cx_curve_t,
        id: cx_curve_dom_param_t,
        p: cx_bn_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecdomain_generator(cv: cx_curve_t, Gx: *mut u8, Gy: *mut u8, len: size_t)
        -> cx_err_t;
}
extern "C" {
    pub fn cx_ecdomain_generator_bn(cv: cx_curve_t, P: *mut cx_ecpoint_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_alloc(P: *mut cx_ecpoint_t, cv: cx_curve_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_destroy(P: *mut cx_ecpoint_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_init(
        P: *mut cx_ecpoint_t,
        x: *const u8,
        x_len: size_t,
        y: *const u8,
        y_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_init_bn(P: *mut cx_ecpoint_t, x: cx_bn_t, y: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_export(
        P: *const cx_ecpoint_t,
        x: *mut u8,
        x_len: size_t,
        y: *mut u8,
        y_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_export_bn(
        P: *const cx_ecpoint_t,
        x: *mut cx_bn_t,
        y: *mut cx_bn_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_compress(
        P: *const cx_ecpoint_t,
        xy_compressed: *mut u8,
        xy_compressed_len: size_t,
        sign: *mut u32,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_decompress(
        P: *mut cx_ecpoint_t,
        xy_compressed: *const u8,
        xy_compressed_len: size_t,
        sign: u32,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_add(
        R: *mut cx_ecpoint_t,
        P: *const cx_ecpoint_t,
        Q: *const cx_ecpoint_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_neg(P: *mut cx_ecpoint_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_rnd_scalarmul(P: *mut cx_ecpoint_t, k: *const u8, k_len: size_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_rnd_scalarmul_bn(P: *mut cx_ecpoint_t, bn_k: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_rnd_fixed_scalarmul(
        P: *mut cx_ecpoint_t,
        k: *const u8,
        k_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_scalarmul(P: *mut cx_ecpoint_t, k: *const u8, k_len: size_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_scalarmul_bn(P: *mut cx_ecpoint_t, bn_k: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_double_scalarmul(
        R: *mut cx_ecpoint_t,
        P: *mut cx_ecpoint_t,
        Q: *mut cx_ecpoint_t,
        k: *const u8,
        k_len: size_t,
        r: *const u8,
        r_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_double_scalarmul_bn(
        R: *mut cx_ecpoint_t,
        P: *mut cx_ecpoint_t,
        Q: *mut cx_ecpoint_t,
        bn_k: cx_bn_t,
        bn_r: cx_bn_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_cmp(
        P: *const cx_ecpoint_t,
        Q: *const cx_ecpoint_t,
        is_equal: *mut bool,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_is_on_curve(R: *const cx_ecpoint_t, is_on_curve: *mut bool) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_is_at_infinity(R: *const cx_ecpoint_t, is_at_infinity: *mut bool)
        -> cx_err_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_ecfp_public_key_s {
    pub curve: cx_curve_t,
    pub W_len: size_t,
    pub W: [u8; 1usize],
}
impl Default for cx_ecfp_public_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_ecfp_private_key_s {
    pub curve: cx_curve_t,
    pub d_len: size_t,
    pub d: [u8; 1usize],
}
impl Default for cx_ecfp_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_ecfp_256_public_key_s {
    pub curve: cx_curve_t,
    pub W_len: size_t,
    pub W: [u8; 65usize],
}
impl Default for cx_ecfp_256_public_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_ecfp_256_private_key_s {
    pub curve: cx_curve_t,
    pub d_len: size_t,
    pub d: [u8; 32usize],
}
impl Default for cx_ecfp_256_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_ecfp_256_extended_private_key_s {
    pub curve: cx_curve_t,
    pub d_len: size_t,
    pub d: [u8; 64usize],
}
impl Default for cx_ecfp_256_extended_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_ecfp_256_public_key_t = cx_ecfp_256_public_key_s;
pub type cx_ecfp_256_private_key_t = cx_ecfp_256_private_key_s;
pub type cx_ecfp_256_extended_private_key_t = cx_ecfp_256_extended_private_key_s;
pub type cx_ecfp_public_key_t = cx_ecfp_256_public_key_s;
pub type cx_ecfp_private_key_t = cx_ecfp_256_private_key_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_ecfp_384_public_key_s {
    pub curve: cx_curve_t,
    pub W_len: size_t,
    pub W: [u8; 97usize],
}
impl Default for cx_ecfp_384_public_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_ecfp_384_private_key_s {
    pub curve: cx_curve_t,
    pub d_len: size_t,
    pub d: [u8; 48usize],
}
impl Default for cx_ecfp_384_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_ecfp_384_private_key_t = cx_ecfp_384_private_key_s;
pub type cx_ecfp_384_public_key_t = cx_ecfp_384_public_key_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_ecfp_512_public_key_s {
    pub curve: cx_curve_t,
    pub W_len: size_t,
    pub W: [u8; 129usize],
}
impl Default for cx_ecfp_512_public_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_ecfp_512_private_key_s {
    pub curve: cx_curve_t,
    pub d_len: size_t,
    pub d: [u8; 64usize],
}
impl Default for cx_ecfp_512_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_ecfp_512_extented_private_key_s {
    pub curve: cx_curve_t,
    pub d_len: size_t,
    pub d: [u8; 128usize],
}
impl Default for cx_ecfp_512_extented_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_ecfp_512_public_key_t = cx_ecfp_512_public_key_s;
pub type cx_ecfp_512_private_key_t = cx_ecfp_512_private_key_s;
pub type cx_ecfp_512_extented_private_key_t = cx_ecfp_512_extented_private_key_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_ecfp_640_public_key_s {
    pub curve: cx_curve_t,
    pub W_len: size_t,
    pub W: [u8; 161usize],
}
impl Default for cx_ecfp_640_public_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_ecfp_640_private_key_s {
    pub curve: cx_curve_t,
    pub d_len: size_t,
    pub d: [u8; 80usize],
}
impl Default for cx_ecfp_640_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_ecfp_640_public_key_t = cx_ecfp_640_public_key_s;
pub type cx_ecfp_640_private_key_t = cx_ecfp_640_private_key_s;
extern "C" {
    pub fn cx_ecfp_add_point_no_throw(
        curve: cx_curve_t,
        R: *mut u8,
        P: *const u8,
        Q: *const u8,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecfp_scalar_mult_no_throw(
        curve: cx_curve_t,
        P: *mut u8,
        k: *const u8,
        k_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecfp_init_public_key_no_throw(
        curve: cx_curve_t,
        rawkey: *const u8,
        key_len: size_t,
        key: *mut cx_ecfp_public_key_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecfp_init_private_key_no_throw(
        curve: cx_curve_t,
        rawkey: *const u8,
        key_len: size_t,
        pvkey: *mut cx_ecfp_private_key_t,
    ) -> cx_err_t;
}
// extern "C" {
//     pub fn cx_ecfp_generate_pair_no_throw(
//         curve: cx_curve_t,
//         pubkey: *mut cx_ecfp_public_key_t,
//         privkey: *mut cx_ecfp_private_key_t,
//         keepprivate: bool,
//     ) -> cx_err_t;
// }
extern "C" {
    pub fn cx_ecfp_generate_pair2_no_throw(
        curve: cx_curve_t,
        pubkey: *mut cx_ecfp_public_key_t,
        privkey: *mut cx_ecfp_private_key_t,
        keepprivate: bool,
        hashID: cx_md_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_eddsa_get_public_key_no_throw(
        pvkey: *const cx_ecfp_private_key_t,
        hashID: cx_md_t,
        pukey: *mut cx_ecfp_public_key_t,
        a: *mut u8,
        a_len: size_t,
        h: *mut u8,
        h_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_edwards_compress_point_no_throw(
        curve: cx_curve_t,
        p: *mut u8,
        p_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_edwards_decompress_point_no_throw(
        curve: cx_curve_t,
        p: *mut u8,
        p_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn os_perso_set_seed(
        identity: core::ffi::c_uint,
        algorithm: core::ffi::c_uint,
        seed: *mut core::ffi::c_uchar,
        length: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn os_perso_derive_and_set_seed(
        identity: core::ffi::c_uchar,
        prefix: *const core::ffi::c_char,
        prefix_length: core::ffi::c_uint,
        passphrase: *const core::ffi::c_char,
        passphrase_length: core::ffi::c_uint,
        words: *const core::ffi::c_char,
        words_length: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn os_perso_set_words(words: *const core::ffi::c_uchar, length: core::ffi::c_uint);
}
extern "C" {
    pub fn os_perso_finalize();
}
extern "C" {
    pub fn os_perso_isonboarded() -> bolos_bool_t;
}
extern "C" {
    pub fn os_perso_set_onboarding_status(
        pin_set: core::ffi::c_uint,
        kind: core::ffi::c_uint,
        count: core::ffi::c_uint,
        total: core::ffi::c_uint,
        isConfirming: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn os_perso_derive_node_bip32(
        curve: cx_curve_t,
        path: *const core::ffi::c_uint,
        pathLength: core::ffi::c_uint,
        privateKey: *mut core::ffi::c_uchar,
        chain: *mut core::ffi::c_uchar,
    );
}
extern "C" {
    pub fn os_perso_derive_node_with_seed_key(
        mode: core::ffi::c_uint,
        curve: cx_curve_t,
        path: *const core::ffi::c_uint,
        pathLength: core::ffi::c_uint,
        privateKey: *mut core::ffi::c_uchar,
        chain: *mut core::ffi::c_uchar,
        seed_key: *mut core::ffi::c_uchar,
        seed_key_length: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn os_perso_derive_eip2333(
        curve: cx_curve_t,
        path: *const core::ffi::c_uint,
        pathLength: core::ffi::c_uint,
        privateKey: *mut core::ffi::c_uchar,
    );
}
pub const OS_SETTING_BRIGHTNESS: os_setting_e = 0;
pub const OS_SETTING_INVERT: os_setting_e = 1;
pub const OS_SETTING_ROTATION: os_setting_e = 2;
pub const OS_SETTING_AUTO_LOCK_DELAY: os_setting_e = 3;
pub const OS_SETTING_SCREEN_LOCK_DELAY: os_setting_e = 4;
pub const OS_SETTING_POWER_OFF_DELAY: os_setting_e = 5;
pub const OS_SETTING_PLANEMODE: os_setting_e = 6;
pub const OS_SETTING_PRIVACY_MODE: os_setting_e = 7;
pub const OS_SETTING_LAST_INT: os_setting_e = 8;
pub const OS_SETTING_SAVER_STRING: os_setting_e = 8;
pub const OS_SETTING_DEVICENAME: os_setting_e = 9;
pub const OS_SETTING_BLEMACADR: os_setting_e = 10;
pub const OS_SETTING_LAST: os_setting_e = 11;
pub type os_setting_e = core::ffi::c_uchar;
pub use self::os_setting_e as os_setting_t;
extern "C" {
    pub fn os_setting_get(
        setting_id: core::ffi::c_uint,
        value: *mut core::ffi::c_uchar,
        maxlen: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn os_setting_set(
        setting_id: core::ffi::c_uint,
        value: *mut core::ffi::c_uchar,
        length: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn u4be_encode(
        buffer: *mut core::ffi::c_uchar,
        offset: core::ffi::c_uint,
        value: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn u4le_encode(
        buffer: *mut core::ffi::c_uchar,
        offset: core::ffi::c_uint,
        value: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bytes_to_hex(
        out: *mut core::ffi::c_char,
        outl: size_t,
        value: *const core::ffi::c_void,
        len: size_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bytes_to_lowercase_hex(
        out: *mut core::ffi::c_char,
        outl: size_t,
        value: *const core::ffi::c_void,
        len: size_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn os_memset4(
        dst: *mut core::ffi::c_void,
        initval: core::ffi::c_uint,
        nbintval: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn os_xor(
        dst: *mut core::ffi::c_void,
        src1: *mut core::ffi::c_void,
        src2: *mut core::ffi::c_void,
        length: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn os_secure_memcmp(
        src1: *const core::ffi::c_void,
        src2: *const core::ffi::c_void,
        length: size_t,
    ) -> core::ffi::c_char;
}
extern "C" {
    pub fn os_memmove(
        dest: *mut core::ffi::c_void,
        src: *const core::ffi::c_void,
        n: size_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn os_memcpy(
        dest: *mut core::ffi::c_void,
        src: *const core::ffi::c_void,
        n: size_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn os_memcmp(
        s1: *const core::ffi::c_void,
        s2: *const core::ffi::c_void,
        n: size_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn os_memset(
        s: *mut core::ffi::c_void,
        c: core::ffi::c_int,
        n: size_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn app_main();
}
extern "C" {
    pub fn os_boot();
}
extern "C" {
    pub fn io_timeout(last_timeout: core::ffi::c_ushort) -> core::ffi::c_ushort;
}
pub const BOLOS_UX_INITIALIZE: bolos_ux_e = 0;
pub const BOLOS_UX_EVENT: bolos_ux_e = 1;
pub const BOLOS_UX_KEYBOARD: bolos_ux_e = 2;
pub const BOLOS_UX_WAKE_UP: bolos_ux_e = 3;
pub const BOLOS_UX_VALIDATE_PIN: bolos_ux_e = 15;
pub const BOLOS_UX_LAST_ID: bolos_ux_e = 16;
pub type bolos_ux_e = core::ffi::c_uchar;
pub use self::bolos_ux_e as bolos_ux_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bolos_ux_params_s {
    pub ux_id: bolos_ux_t,
    pub len: core::ffi::c_uint,
}
impl Default for bolos_ux_params_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type bolos_ux_params_t = bolos_ux_params_s;
extern "C" {
    pub fn os_ux(params: *mut bolos_ux_params_t) -> core::ffi::c_uint;
}
extern "C" {
    pub fn os_ux_result(params: *mut bolos_ux_params_t);
}
extern "C" {
    pub fn os_ux_blocking(params: *mut bolos_ux_params_t) -> core::ffi::c_uint;
}
extern "C" {
    pub fn io_seph_send(buffer: *const core::ffi::c_uchar, length: core::ffi::c_ushort);
}
extern "C" {
    pub fn io_seph_is_status_sent() -> core::ffi::c_uint;
}
extern "C" {
    pub fn io_seph_recv(
        buffer: *mut core::ffi::c_uchar,
        maxlength: core::ffi::c_ushort,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_ushort;
}
extern "C" {
    pub fn io_seph_init();
}
extern "C" {
    pub fn io_seproxyhal_init();
}
extern "C" {
    pub fn io_seproxyhal_init_ux();
}
extern "C" {
    pub fn io_seproxyhal_init_button();
}
extern "C" {
    pub fn io_exchange_al(
        channel_and_flags: core::ffi::c_uchar,
        tx_len: core::ffi::c_ushort,
    ) -> core::ffi::c_ushort;
}
extern "C" {
    pub fn os_io_seproxyhal_get_app_name_and_version() -> core::ffi::c_uint;
}
extern "C" {
    pub fn USB_power(enabled: core::ffi::c_uchar);
}
extern "C" {
    pub fn io_seproxyhal_handle_usb_event();
}
extern "C" {
    pub fn io_seproxyhal_handle_usb_ep_xfer_event();
}
extern "C" {
    pub fn io_seproxyhal_get_ep_rx_size(epnum: u8) -> u16;
}
extern "C" {
    pub fn io_seproxyhal_handle_event() -> core::ffi::c_uint;
}
extern "C" {
    pub fn io_seproxyhal_general_status();
}
extern "C" {
    pub fn os_io_seproxyhal_general_status_processing();
}
extern "C" {
    pub fn io_usb_send_apdu_data(buffer: *mut core::ffi::c_uchar, length: core::ffi::c_ushort);
}
extern "C" {
    pub fn io_usb_send_apdu_data_ep0x83(
        buffer: *mut core::ffi::c_uchar,
        length: core::ffi::c_ushort,
    );
}
extern "C" {
    pub fn io_usb_send_ep(
        ep: core::ffi::c_uint,
        buffer: *mut core::ffi::c_uchar,
        length: core::ffi::c_ushort,
        timeout: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn io_usb_ccid_reply(buffer: *mut core::ffi::c_uchar, length: core::ffi::c_ushort);
}
extern "C" {
    pub fn io_set_timeout(timeout: core::ffi::c_uint);
}
pub const APDU_IDLE: io_apdu_state_e = 0;
pub const APDU_BLE: io_apdu_state_e = 1;
pub const APDU_BLE_WAIT_NOTIFY: io_apdu_state_e = 2;
pub const APDU_NFC_M24SR: io_apdu_state_e = 3;
pub const APDU_NFC_M24SR_SELECT: io_apdu_state_e = 4;
pub const APDU_NFC_M24SR_FIRST: io_apdu_state_e = 5;
pub const APDU_NFC_M24SR_RAPDU: io_apdu_state_e = 6;
pub const APDU_USB_HID: io_apdu_state_e = 7;
pub const APDU_USB_CCID: io_apdu_state_e = 8;
pub const APDU_U2F: io_apdu_state_e = 9;
pub const APDU_RAW: io_apdu_state_e = 10;
pub const APDU_USB_WEBUSB: io_apdu_state_e = 11;
pub type io_apdu_state_e = core::ffi::c_uchar;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_seph_s {
    pub apdu_state: io_apdu_state_e,
    pub apdu_length: core::ffi::c_ushort,
    pub io_flags: core::ffi::c_ushort,
    pub apdu_media: io_apdu_media_t,
    pub ms: core::ffi::c_uint,
    pub usb_ep_xfer_len: [core::ffi::c_uchar; 6usize],
    pub usb_ep_timeouts: [io_seph_s__bindgen_ty_1; 6usize],
    pub transfer_mode: core::ffi::c_uchar,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct io_seph_s__bindgen_ty_1 {
    pub timeout: core::ffi::c_ushort,
}
impl Default for io_seph_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type io_seph_app_t = io_seph_s;
extern "C" {
    pub static mut G_io_app: io_seph_app_t;
}
extern "C" {
    pub fn io_seproxyhal_setup_ticker(interval_ms: core::ffi::c_uint);
}
extern "C" {
    pub fn io_seproxyhal_power_off();
}
extern "C" {
    pub fn io_seproxyhal_se_reset();
}
extern "C" {
    pub fn io_seproxyhal_disable_io();
}
extern "C" {
    pub fn io_seph_ux_redisplay();
}
extern "C" {
    pub fn io_seproxyhal_io_heartbeat();
}
extern "C" {
    pub fn os_io_seph_recv_and_process(
        dont_process_ux_events: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cx_aes_key_s {
    pub size: size_t,
    pub keys: [u8; 32usize],
}
pub type cx_aes_key_t = cx_aes_key_s;
extern "C" {
    pub fn cx_aes_set_key_hw(key: *const cx_aes_key_t, mode: u32) -> cx_err_t;
}
extern "C" {
    pub fn cx_aes_reset_hw();
}
extern "C" {
    pub fn cx_aes_block_hw(
        inblock: *const core::ffi::c_uchar,
        outblock: *mut core::ffi::c_uchar,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_crc32_hw(buf: *const core::ffi::c_void, len: size_t) -> u32;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cx_des_key_s {
    pub size: u8,
    pub keys: [u8; 24usize],
}
pub type cx_des_key_t = cx_des_key_s;
extern "C" {
    pub fn cx_des_set_key_hw(keys: *const cx_des_key_t, mode: u32) -> cx_err_t;
}
extern "C" {
    pub fn cx_des_reset_hw();
}
extern "C" {
    pub fn cx_des_block_hw(inblock: *const core::ffi::c_uchar, outblock: *mut core::ffi::c_uchar);
}
extern "C" {
    pub fn cx_trng_get_random_data(buf: *mut u8, size: size_t);
}
extern "C" {
    pub fn cx_trng_selftest();
}
extern "C" {
    pub fn cx_trng_init();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_ripemd160_s {
    pub header: cx_hash_header_s,
    pub blen: size_t,
    pub block: [u8; 64usize],
    pub acc: [u8; 20usize],
}
impl Default for cx_ripemd160_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_ripemd160_t = cx_ripemd160_s;
extern "C" {
    pub fn cx_ripemd160_init_no_throw(hash: *mut cx_ripemd160_t) -> cx_err_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_sha256_s {
    pub header: cx_hash_header_s,
    pub blen: size_t,
    pub block: [u8; 64usize],
    pub acc: [u8; 32usize],
}
impl Default for cx_sha256_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_sha256_t = cx_sha256_s;
extern "C" {
    pub fn cx_sha224_init_no_throw(hash: *mut cx_sha256_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_sha256_init_no_throw(hash: *mut cx_sha256_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_hash_sha256(in_: *const u8, len: size_t, out: *mut u8, out_len: size_t) -> size_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_sha512_s {
    pub header: cx_hash_header_s,
    pub blen: size_t,
    pub block: [u8; 128usize],
    pub acc: [u8; 64usize],
}
impl Default for cx_sha512_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_sha512_t = cx_sha512_s;
extern "C" {
    pub fn cx_sha384_init_no_throw(hash: *mut cx_sha512_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_sha512_init_no_throw(hash: *mut cx_sha512_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_hash_sha512(in_: *const u8, in_len: size_t, out: *mut u8, out_len: size_t) -> size_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_sha3_s {
    pub header: cx_hash_header_s,
    pub output_size: size_t,
    pub block_size: size_t,
    pub blen: size_t,
    pub block: [u8; 200usize],
    pub acc: [uint64bits_t; 25usize],
}
impl Default for cx_sha3_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_sha3_t = cx_sha3_s;
extern "C" {
    pub fn cx_sha3_init_no_throw(hash: *mut cx_sha3_t, size: size_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_keccak_init_no_throw(hash: *mut cx_sha3_t, size: size_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_shake128_init_no_throw(hash: *mut cx_sha3_t, out_size: size_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_shake256_init_no_throw(hash: *mut cx_sha3_t, out_size: size_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_sha3_xof_init_no_throw(
        hash: *mut cx_sha3_t,
        size: size_t,
        out_length: size_t,
    ) -> cx_err_t;
}
pub const BLAKE2B_BLOCKBYTES: blake2b_constant = 128;
pub const BLAKE2B_OUTBYTES: blake2b_constant = 64;
pub const BLAKE2B_KEYBYTES: blake2b_constant = 64;
pub const BLAKE2B_SALTBYTES: blake2b_constant = 16;
pub const BLAKE2B_PERSONALBYTES: blake2b_constant = 16;
pub type blake2b_constant = core::ffi::c_uchar;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blake2b_state__ {
    pub h: [u64; 8usize],
    pub t: [u64; 2usize],
    pub f: [u64; 2usize],
    pub buf: [u8; 128usize],
    pub buflen: size_t,
    pub outlen: size_t,
    pub last_node: u8,
}
impl Default for blake2b_state__ {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type blake2b_state = blake2b_state__;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_blake2b_s {
    pub header: cx_hash_header_s,
    pub output_size: size_t,
    pub ctx: blake2b_state__,
}
impl Default for cx_blake2b_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_blake2b_t = cx_blake2b_s;
extern "C" {
    pub fn cx_blake2b_init_no_throw(hash: *mut cx_blake2b_t, out_len: size_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_blake2b_init2_no_throw(
        hash: *mut cx_blake2b_t,
        out_len: size_t,
        salt: *mut u8,
        salt_len: size_t,
        perso: *mut u8,
        perso_len: size_t,
    ) -> cx_err_t;
}
pub type BitSequence = core::ffi::c_uchar;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hashState_s {
    pub chaining: [[u8; 16usize]; 8usize],
    pub block_counter: u64,
    pub hashlen: core::ffi::c_uint,
    pub buffer: [BitSequence; 128usize],
    pub buf_ptr: core::ffi::c_uint,
    pub columns: core::ffi::c_uint,
    pub rounds: core::ffi::c_uint,
    pub statesize: core::ffi::c_uint,
}
impl Default for hashState_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type hashState = hashState_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_groestl_s {
    pub output_size: core::ffi::c_uint,
    pub ctx: hashState_s,
}
impl Default for cx_groestl_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_groestl_t = cx_groestl_s;
extern "C" {
    pub fn cx_groestl_get_output_size(ctx: *const cx_groestl_t) -> size_t;
}
extern "C" {
    pub fn cx_groestl_init_no_throw(hash: *mut cx_groestl_t, size: size_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_groestl(
        hash: *mut cx_groestl_t,
        mode: u32,
        in_: *const u8,
        len: size_t,
        out: *mut u8,
        out_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_groestl_update(ctx: *mut cx_groestl_t, data: *const u8, len: size_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_groestl_final(ctx: *mut cx_groestl_t, digest: *mut u8) -> cx_err_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_hmac_t {
    pub key: [u8; 128usize],
    pub hash_ctx: cx_hash_t,
}
impl Default for cx_hmac_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_hmac_ripemd160_t {
    pub key: [u8; 128usize],
    pub hash_ctx: cx_ripemd160_t,
}
impl Default for cx_hmac_ripemd160_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn cx_hmac_ripemd160_init_no_throw(
        hmac: *mut cx_hmac_ripemd160_t,
        key: *const u8,
        key_len: size_t,
    ) -> cx_err_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_hmac_sha256_t {
    pub key: [u8; 128usize],
    pub hash_ctx: cx_sha256_t,
}
impl Default for cx_hmac_sha256_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn cx_hmac_sha224_init(
        hmac: *mut cx_hmac_sha256_t,
        key: *const u8,
        key_len: core::ffi::c_uint,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_hmac_sha256_init_no_throw(
        hmac: *mut cx_hmac_sha256_t,
        key: *const u8,
        key_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_hmac_sha256(
        key: *const u8,
        key_len: size_t,
        in_: *const u8,
        len: size_t,
        mac: *mut u8,
        mac_len: size_t,
    ) -> size_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_hmac_sha512_t {
    pub key: [u8; 128usize],
    pub hash_ctx: cx_sha512_t,
}
impl Default for cx_hmac_sha512_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn cx_hmac_sha384_init(
        hmac: *mut cx_hmac_sha512_t,
        key: *const u8,
        key_len: core::ffi::c_uint,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_hmac_sha512_init_no_throw(
        hmac: *mut cx_hmac_sha512_t,
        key: *const u8,
        key_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_hmac_sha512(
        key: *const u8,
        key_len: size_t,
        in_: *const u8,
        len: size_t,
        mac: *mut u8,
        mac_len: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn cx_hmac_no_throw(
        hmac: *mut cx_hmac_t,
        mode: u32,
        in_: *const u8,
        len: size_t,
        mac: *mut u8,
        mac_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_hmac_init(
        hmac: *mut cx_hmac_t,
        hash_id: cx_md_t,
        key: *const u8,
        key_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_hmac_update(hmac: *mut cx_hmac_t, in_: *const u8, in_len: size_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_hmac_final(ctx: *mut cx_hmac_t, out: *mut u8, out_len: *mut size_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_pbkdf2_no_throw(
        md_type: cx_md_t,
        password: *const u8,
        passwordlen: size_t,
        salt: *mut u8,
        saltlen: size_t,
        iterations: u32,
        out: *mut u8,
        outLength: size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_rng_no_throw(buffer: *mut u8, len: size_t);
}
pub type cx_rng_u32_range_randfunc_t = ::core::option::Option<unsafe extern "C" fn() -> u32>;
extern "C" {
    pub fn cx_rng_u32_range_func(a: u32, b: u32, randfunc: cx_rng_u32_range_randfunc_t) -> u32;
}
extern "C" {
    pub fn cx_rng_rfc6979(
        hash_id: cx_md_t,
        x: *const u8,
        x_len: size_t,
        h1: *const u8,
        h1_len: size_t,
        q: *const u8,
        q_len: size_t,
        out: *mut u8,
        out_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_cmp_no_throw(
        a: *const u8,
        b: *const u8,
        length: size_t,
        diff: *mut core::ffi::c_int,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_add_no_throw(r: *mut u8, a: *const u8, b: *const u8, len: size_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_sub_no_throw(r: *mut u8, a: *const u8, b: *const u8, len: size_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_mult_no_throw(r: *mut u8, a: *const u8, b: *const u8, len: size_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_addm_no_throw(
        r: *mut u8,
        a: *const u8,
        b: *const u8,
        m: *const u8,
        len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_subm_no_throw(
        r: *mut u8,
        a: *const u8,
        b: *const u8,
        m: *const u8,
        len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_multm_no_throw(
        r: *mut u8,
        a: *const u8,
        b: *const u8,
        m: *const u8,
        len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_modm_no_throw(
        v: *mut u8,
        len_v: size_t,
        m: *const u8,
        len_m: size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_powm_no_throw(
        r: *mut u8,
        a: *const u8,
        e: *const u8,
        len_e: size_t,
        m: *const u8,
        len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_invprimem_no_throw(
        r: *mut u8,
        a: *const u8,
        m: *const u8,
        len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_invintm_no_throw(r: *mut u8, a: u32, m: *const u8, len: size_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_is_prime_no_throw(r: *const u8, len: size_t, prime: *mut bool) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_next_prime_no_throw(r: *mut u8, len: u32) -> cx_err_t;
}
extern "C" {
    pub fn cx_des_init_key_no_throw(
        rawkey: *const u8,
        key_len: size_t,
        key: *mut cx_des_key_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_des_iv_no_throw(
        key: *const cx_des_key_t,
        mode: u32,
        iv: *const u8,
        iv_len: size_t,
        in_: *const u8,
        in_len: size_t,
        out: *mut u8,
        out_len: *mut size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_des_no_throw(
        key: *const cx_des_key_t,
        mode: u32,
        in_: *const u8,
        in_len: size_t,
        out: *mut u8,
        out_len: *mut size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_des_enc_block(key: *const cx_des_key_t, inblock: *const u8, outblock: *mut u8);
}
extern "C" {
    pub fn cx_des_dec_block(key: *const cx_des_key_t, inblock: *const u8, outblock: *mut u8);
}
extern "C" {
    pub fn cx_aes_init_key_no_throw(
        rawkey: *const u8,
        key_len: size_t,
        key: *mut cx_aes_key_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_aes_iv_no_throw(
        key: *const cx_aes_key_t,
        mode: u32,
        iv: *const u8,
        iv_len: size_t,
        in_: *const u8,
        in_len: size_t,
        out: *mut u8,
        out_len: *mut size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_aes_no_throw(
        key: *const cx_aes_key_t,
        mode: u32,
        in_: *const u8,
        in_len: size_t,
        out: *mut u8,
        out_len: *mut size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_aes_enc_block(
        key: *const cx_aes_key_t,
        inblock: *const u8,
        outblock: *mut u8,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_aes_dec_block(
        key: *const cx_aes_key_t,
        inblock: *const u8,
        outblock: *mut u8,
    ) -> cx_err_t;
}
// extern "C" {
//     pub fn cx_ecdsa_sign_no_throw(
//         pvkey: *const cx_ecfp_private_key_t,
//         mode: u32,
//         hashID: cx_md_t,
//         hash: *const u8,
//         hash_len: size_t,
//         sig: *mut u8,
//         sig_len: *mut size_t,
//         info: *mut u32,
//     ) -> cx_err_t;
// }
// extern "C" {
//     pub fn cx_ecdsa_verify_no_throw(
//         pukey: *const cx_ecfp_public_key_t,
//         hash: *const u8,
//         hash_len: size_t,
//         sig: *const u8,
//         sig_len: size_t,
//     ) -> bool;
// }
// extern "C" {
//     pub fn cx_eddsa_sign_no_throw(
//         pvkey: *const cx_ecfp_private_key_t,
//         hashID: cx_md_t,
//         hash: *const u8,
//         hash_len: size_t,
//         sig: *mut u8,
//         sig_len: size_t,
//     ) -> cx_err_t;
// }
// extern "C" {
//     pub fn cx_eddsa_verify_no_throw(
//         pukey: *const cx_ecfp_public_key_t,
//         hashID: cx_md_t,
//         hash: *const u8,
//         hash_len: size_t,
//         sig: *const u8,
//         sig_len: size_t,
//     ) -> bool;
// }
extern "C" {
    pub fn cx_encode_coord(coord: *mut u8, len: core::ffi::c_int, sign: core::ffi::c_int);
}
extern "C" {
    pub fn cx_decode_coord(coord: *mut u8, len: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn cx_ecschnorr_sign_no_throw(
        pvkey: *const cx_ecfp_private_key_t,
        mode: u32,
        hashID: cx_md_t,
        msg: *const u8,
        msg_len: size_t,
        sig: *mut u8,
        sig_len: *mut size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecschnorr_verify(
        pukey: *const cx_ecfp_public_key_t,
        mode: u32,
        hashID: cx_md_t,
        msg: *const u8,
        msg_len: size_t,
        sig: *const u8,
        sig_len: size_t,
    ) -> bool;
}
extern "C" {
    pub fn cx_ecdh_no_throw(
        pvkey: *const cx_ecfp_private_key_t,
        mode: u32,
        P: *const u8,
        P_len: size_t,
        secret: *mut u8,
        secret_len: size_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_crc16(buffer: *const core::ffi::c_void, len: size_t) -> u16;
}
extern "C" {
    pub fn cx_crc16_update(crc: u16, buffer: *const core::ffi::c_void, len: size_t) -> u16;
}
